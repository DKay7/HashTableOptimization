* Исследование и оптимизация хэш-таблицы
  :PROPERTIES:
  :CUSTOM_ID: исследование-и-оптимизация-хэш-таблицы
  :END:

Данное задание посвящено написанию, исследованию работы и оптимизации
структуры данных хэш таблица.

** Некоторые детали реализации
   :PROPERTIES:
   :CUSTOM_ID: некоторые-детали-реализации
   :END:

В первую очередь, хотелось бы отметить некоторые отличительные черты
данной хэш-таблицы. 1. Коллизии разрешаются методом цепочек 2. Сама
таблица умеет расширяться, когда коэффициент заполнения (количество
элементов, на одну ячейку хэш-таблицы) превышает 1.5 3. Хэш-таблица
является "кэш-френдли", то есть реализация подразумевает уменьшение
кэш-мисов. Достигнуто это следующим образом: 1. Во-первых, связный
список, используемый для разрешения коллизий представляет из себя
массив, то есть хранится в памяти последовательно, что увеличивает
вероятность того, что все элементы списка окажутся в кэше 2. Во-вторых,
метод цепочек немного видоизменен. Стандратная реализация предполагает,
что каждый элемент хэш-таблицы имеет свой связный список, в который
кладутся элементы при возникновении коллизий. В данном же проекте,
связный список -- один, а каждый элемент хранит начало подсписка и
длину. Такое решение также должно уменьшать количество кэшмисов, потому
что и сама таблица, и связный список -- массивы, хранящиеся в памяти
последовательно. В дальнейшем, один элемент хэш-таблицы (то есть
подсписок и его длину) мы будем называть бакетом (от англ. bucket --
ведро).

** Данные
   :PROPERTIES:
   :CUSTOM_ID: данные
   :END:

Теперь пару слов о данных, на которых производились тесты. Для
объективности тестирования, данных должно быть много, поэтому было
принято решение взять англо-русский словарь на 64000 слов и выражений.
После удаления дубликатов, пустых значений (без перевода), и слишком
длинных строк, в словаре осталось около 55000 строк формата "английское
выражение -- перевод". Ключом хэштаблицы являлась фраза на английском, а
значением -- перевод.

** Тестирование
   :PROPERTIES:
   :CUSTOM_ID: тестирование
   :END:

В первую очередь, необходимо выбрать наилучшую хэш-функцию, дающую
минимум коллизий. Для тестирования были предложены следующие функции:

1. =const_hash=:

#+BEGIN_SRC C++
    uint64_t const_hash (char* str)
    {   
        (void ) str;
        return 1ul;
    }
#+END_SRC

2. =first_letter_code_hash=:
   =C++ uint64_t first_letter_code_hash (char* str) {     assert (str);  return (uint64_t)str[0]; }=C++

3. =len_hash=:

#+BEGIN_SRC C++
    uint64_t len_hash (char* str)
    {   
        assert (str);
        return strlen (str);
    }
#+END_SRC

4. =sum_of_letter_codes_hash=:

#+BEGIN_SRC C++
    uint64_t sum_of_letter_codes_hash (char* str)
    {
        assert (str);

        uint64_t hash = 0;

        while (*str++ != 0)
        {
            hash += (uint64_t) (*str);
        }

        return hash;
    }
#+END_SRC

5. =rol_hash=:

#+BEGIN_SRC C++
    uint64_t rol_hash (char* str)
    {   
        assert (str);

        const int shift_size_bits = CHAR_BIT * sizeof (uint64_t) - 1;
        const uint64_t highest_bit_mask = (uint64_t)1 << shift_size_bits;

        uint64_t hash = (uint64_t)str[0];
        
        while (*(str++) != 0)
        {
            hash = ((hash << 1) + ((hash & highest_bit_mask) >> shift_size_bits)) ^ (uint64_t)(*str);
        }

        return hash;
    }
#+END_SRC

6. =ror_hash=:

#+BEGIN_SRC C++
    uint64_t ror_hash (char* str)
    {
        assert (str);

        const int shift_size_bits = CHAR_BIT * sizeof (uint64_t) - 1;
        const int lowest_bit_mask = 1;

        uint64_t hash = (uint64_t)str[0];

        while (*(str++) != 0)
        {
            hash = ((hash >> 1) + ((hash & lowest_bit_mask) << shift_size_bits)) ^ (uint64_t)(*str);
        }

        return hash;
    }
#+END_SRC

7. =polynimial_rolling_hash=:

#+BEGIN_SRC C++
    uint64_t polynimial_rolling_hash (char* str)
    {
        assert (str);
        const int m = 1e9 + 9;
        const int p = 53;

        uint64_t hash = 0;
        uint64_t power = 1;

        while (*(str++) != 0)
        {
            hash = (hash + (uint64_t)((*str) - 'a' + 1) * power) % m;
            power = (p * power) % m;
        }

        return hash;
    }
#+END_SRC

Тестирование произоводилось следующим образом: 1. Создавалось два
объекта хэш-таблицы, с начальным размером в 50000 элементов. Одна
хэштаблица могла расширяться, вторая -- нет. 2. В хэш-таблицу
вставлялись элементы из словаря по описанному выше принципу. 3.
Производился замер времени вставки, вычислялась дисперсия распределения
длин подсписков (напомню, что каждый эелмент хэш-таблицы предствляет из
себя подсписок, это необходимо для разрешения коллизий).

По результатам работы были составлены следующие таблицы:

Для хэш-таблицы постоянного размера: 
| *Имя хэш-функции*             | *Дисперсия*   | *Время, секунды*  | *Размер таблицы*      |
|-------------------------------|---------------|-------------------|-----------------------|
| *const_hash*                  | nan           | 19.28271          | 50000                 | 
| *first_letter_code_hash*      | 3384202.89    | 1.15411           | 50000                 |
| *len_hash*                    | 4418417.99    | 2.86783           | 50000                 | 
| *sum_of_letter_codes_hash*    | 1049.22       | 0.07684           | 50000                 | 
|*ror_hash*                     | 16.776        | 0.02411           | 50000                 | 
| *rol_hash*                    | 5.044         | 0.01937           | 50000                 | 
| *polynimial_rolling_hash*     | 1.136         | 0.02191           | 50000                 |

Для расширяющейся хэш-таблицы: 
| *Имя хэш-функции*     | *Дисперсия* | *Время, секунды* | *Начальный размер таблицы* | *Конечный размер таблицы* |
|----------------------------------|---------------|--------------------|------------------------------|-----------------------------|
| *const_hash*                  | nan           | 23.9094 | 50000 | 100000 |
| *first_letter_code_hash*      | 3384202.89    | 1.76362 | 50000 | 100000 | 
| *len_hash*                    | 4418417.99    | 2.92111 | 50000 | 100000 | 
| *sum_of_letter_codes_hash*    | 1049.22       | 0.08114 | 50000 | 100000 | 
| *ror_hash*                    | 16.77         | 0.03716 | 50000 | 100000 | 
| *rol_hash*                    | 3.54          | 0.03268 | 50000 | 100000 | 
| *polynimial_rolling_hash*     | 0.661         | 0.03734 | 50000 | 100000 |

Из таблиц можно сделать следующие выводы: 1. Никогда не используйте
=cons_hash=, это бессмысленно.

2. Наилучшими оказались =rol_hash=, =ror_hash= и
   =polynimial_rolling_hash=.

3. По верхним строчкам таблицы может показаться, что добавление функции
   расширения, не дает ничего, кроме увелечения времени работы (при
   расширении нужно пересчитать хэш всех элементов), тем не менее, по
   нижним строчкам видно, что засчет расширения таблицы время вставки
   уменьшилось настолько сильно, что общее время работы либо
   уменьшилось, либо почти не изменилось. Это говорит о том, что функция
   расширения таблицы, в совокупности с хорошей хэш-функцией уменьшает
   время вставки.

4. Как и со временем работы, если посмотреть на верхние строчки таблицы,
   можно подумать, что увеличение размера таблицы никак не повлияло на
   дисперсию размеров бакетов, но вызвано это было плохой хэш-функцией.
   Если же посмотреть на нижние строчки таблицы, в которых предствлены
   относительно хорошие хэш-функции, можно понять, что увеличение
   размера таблицы на порядок уменьшило дисперсию.

Таким образом, были приняты следующие решения: 1. Использовать
=polynimial_rolling_hash= в качестве хэш-функции. 2. Оставить
хэш-таблицу расширяемой.

* Оптимизация
  :PROPERTIES:
  :CUSTOM_ID: оптимизация
  :END:

Теперь, когда мы выяснили, какие параметры таблицы использовать лучше
всего, перейдем к оптимизации.

Первым делом отметим каким образом мы тестировали хэш-таблицу на
производительность. Для этого приведем код функции =main= исполняемой
программы.

#+BEGIN_SRC C++
    int main()
    {
        Text csv_data = {};
        TextCtor (&csv_data, "../data/en-ru.csv");
        const size_t idx_arr_size = 256;
        int* idx_for_search_array = (int*) calloc (idx_arr_size, sizeof(*idx_for_search_array));

        HashTable<char*, char*> ht = {};
        HashTableCtor<char*, char*> (&ht, 50000, polynimial_rolling_hash, key_equality);

        FillIndexesArrayWithRandomValues (idx_for_search_array, idx_arr_size, csv_data.non_empty_lines);

        FillHashTableFromStrCSV (&csv_data, &ht);

        SearchSpeedTest (idx_for_search_array, idx_arr_size, &ht, &csv_data);

    }
#+END_SRC

Как видно из приведенного выше кода, если не вдаваться в детали
реализации, мы создавали массив из 256 ключей, который заполняли
случайными ключами из словаря, после этого мы искали все 256 ключей в
хэш-таблице.

Профилирование производилось при помощи утилиты =perf=. Для сбора
статистики запускалась следующая команда.

=sudo perf record -e cpu-clock,cache-misses,branch-misses --freq=10000 ./main=

Первый тест, без оптимизаций (в дальнейшем мы будем сравнивать
результаты оптимизаций с ним) дал следующие показатели:

#+BEGIN_HTML
  <details>
#+END_HTML


#+BEGIN_HTML
<summary>Результат первого теста.</summary>
#+END_HTML

#+BEGIN_SRC
# To display the perf.data header info, please use --header/--header-only options.
#
# dso: main
#
# Total Lost Samples: 0
#
# Samples: 340  of event 'cpu-clock'
# Event count (approx.): 34000000
#
# Overhead  Command  Symbol                                    
# ........  .......  ..........................................
#
    16.18%  main     [.] polynimial_rolling_hash
    15.88%  main     [.] HashTableInsert<char*, char*>
     6.47%  main     [.] LLIncreaseSize<HT_Pair<char*, char*> >
     2.06%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     1.18%  main     [.] FillLinesArray
     1.18%  main     [.] 0x0000000000001270
     0.59%  main     [.] FillHashTableFromStrCSV
     0.59%  main     [.] 0x00000000000011f0
     0.29%  main     [.] key_equality
     0.29%  main     [.] main


# Samples: 282  of event 'cache-misses'
# Event count (approx.): 790389
#
# Overhead  Command  Symbol                                    
# ........  .......  ..........................................
#
    13.07%  main     [.] polynimial_rolling_hash
    12.88%  main     [.] HashTableInsert<char*, char*>
     8.18%  main     [.] LLIncreaseSize<HT_Pair<char*, char*> >
     0.92%  main     [.] key_equality
     0.60%  main     [.] HashTableFind<char*, char*>
     0.35%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     0.33%  main     [.] main
     0.28%  main     [.] FillLinesArray
     0.19%  main     [.] FillHashTableFromStrCSV


# Samples: 248  of event 'branch-misses'
# Event count (approx.): 312338
#
# Overhead  Command  Symbol                                    
# ........  .......  ..........................................
#
    27.37%  main     [.] HashTableInsert<char*, char*>
     4.60%  main     [.] polynimial_rolling_hash
     1.13%  main     [.] FillLinesArray
     0.84%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     0.78%  main     [.] LLIncreaseSize<HT_Pair<char*, char*> >
     0.36%  main     [.] FillHashTableFromStrCSV
     0.27%  main     [.] HashTableFind<char*, char*>


#
# (Cannot load tips.txt file, please install perf!)
#

#+END_SRC


#+BEGIN_HTML
  </details>
#+END_HTML

Первый тест выявил две проблемы:
1. Функция хэширования работает достаточно медленно для функции, которая вызывается при любой попытке вставить элемент или найти элемент по ключу
2. Вставка в хэш-таблицу довольно медленная, поскольку содержит операцию взятия остатка по составному числу

После первого теста было решено провести две оптимизации:
1. Сделать размер хэш-таблицы степенью двойки, что позволит использовать опреатор =&= вместо оператора =%=
2. Оптимизировать функцию =polynimial_rolling_hash=, а именно:
    1. Протестировать, сильно ли ухудшится хэш, если убрать оператор =%=.
    2. Если оптимизация выше не поможет, переписать часть или всю функцию на ассемблере.
3. Проверка бранч-мисов в функции =HashTableInsert<char*, char*>= выявила, что больше всего мисов происходит в строчках:

#+BEGIN_SRC
    if (hash_table->buckets[position].status == BUCKET_EMPTY)
#+END_SRC

На них приходится почти 85+% всех мисов в функции. Пока неясно, как это чинить, так что оставим напоследок.

Для начала мы протестировали новую хэш-функцию (без операции взятия остатка от деления), дисперсия оказалась такой же с точностью до -6 порядка, поэтому было принято решение убрать операцию взятия остатка от деления из хэша.

После этого, в конструкторе хэш-таблицы были добавлены следующие строки:

#+BEGIN_SRC
    int table_int_log = (int) ceil (log2 (table_size));
    table_size = pow (2, table_int_log);
#+END_SRC

Благодаря им, мы можем быть уверены, что размер таблицы всегда будет степенью двойки. Кроме того, было проверено, что при расширении хэш-таблицы ее размер увеличивается в кратное 2 число раз. В функции поиска положения по ключу строка =key_hash % hash_table->size= заменилась на =key_hash & (hash_table->size - 1)=.

На всякий случай, мы измерили дисперсию хэш-функции в измененной хэш-таблице, и она уменьшилась на 83% (=D_old = 0.6681=, =D_new = 0.5533=).

Все оптимизации были проделаны, можно запускать второй тест.

#+BEGIN_HTML
  <details>
#+END_HTML

#+BEGIN_HTML
<summary>Резульат второго теста.</summary>
#+END_HTML

#+BEGIN_SRC
# To display the perf.data header info, please use --header/--header-only options.
#
# dso: main
#
# Total Lost Samples: 0
#
# Samples: 245  of event 'cpu-clock'
# Event count (approx.): 24500000
#
# Overhead  Command  Symbol                                    
# ........  .......  ..........................................
#
    19.59%  main     [.] HashTableInsert<char*, char*>
     7.76%  main     [.] polynimial_rolling_hash
     4.90%  main     [.] LLIncreaseSize<HT_Pair<char*, char*> >
     2.86%  main     [.] HashTableCtor<char*, char*>
     2.45%  main     [.] FillLinesArray
     2.04%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     2.04%  main     [.] __HashTableGetPosition<char*, char*>
     0.82%  main     [.] FillHashTableFromStrCSV
     0.41%  main     [.] HashTableFind<char*, char*>
     0.41%  main     [.] 0x0000000000001230


# Samples: 213  of event 'cache-misses'
# Event count (approx.): 780701
#
# Overhead  Command  Symbol                                    
# ........  .......  ..........................................
#
    17.58%  main     [.] HashTableInsert<char*, char*>
     6.90%  main     [.] polynimial_rolling_hash
     3.62%  main     [.] LLIncreaseSize<HT_Pair<char*, char*> >
     2.20%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     1.92%  main     [.] FillHashTableFromStrCSV
     1.11%  main     [.] __HashTableGetPosition<char*, char*>
     0.76%  main     [.] HashTableCtor<char*, char*>
     0.48%  main     [.] FillLinesArray
     0.46%  main     [.] HashTableFind<char*, char*>


# Samples: 182  of event 'branch-misses'
# Event count (approx.): 303806
#
# Overhead  Command  Symbol                                   
# ........  .......  .........................................
#
    31.23%  main     [.] HashTableInsert<char*, char*>
     3.68%  main     [.] LLInsertAfter<HT_Pair<char*, char*> >
     1.53%  main     [.] FillLinesArray
     1.17%  main     [.] __HashTableGetPosition<char*, char*>
     1.02%  main     [.] polynimial_rolling_hash
     0.42%  main     [.] FillHashTableFromStrCSV

#+END_SRC

#+BEGIN_HTML
  </details>
#+END_HTML

Как видно, первая оптимизация принесла свои плоды. Теперь =polynimial_rolling_hash= спустился по всем показателям: стал занимать в 2 раза меньше времени, уменьшились кэш- и бранч- мисы в этой функции. Также из тестов видно, что наш следующий кандидат на оптимизацию -- =HashTableInsert<char*, char*>=. Давайте посмотрим детальнее, какая именно инструкция занимает столько времени. 

#+BEGIN_HTML
  <details>
  <summary>Трейс  HashTableInsert</summary>
#+END_HTML
#+BEGIN_SRC

 Percent |	Source code & Disassembly of main for cpu-clock (48 samples, percent: local period)
---------------------------------------------------------------------------------------------------
         :
         :
         :
         :          Дизассемблирование раздела .text:
         :
         :          0000000000002d63 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)>:
         :          _Z15HashTableInsertIPcS0_EbP9HashTableIT_T0_ES2_S3_():
         :          }
         :
         :          //flexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
         :
         :          template <typename K, typename V>
         :          bool HashTableInsert (HashTable<K, V>* hash_table, K key, V value)
    0.00 :   2d63:       endbr64
    0.00 :   2d67:       push   r15
    0.00 :   2d69:       push   r14
    0.00 :   2d6b:       push   r13
    0.00 :   2d6d:       push   r12
    0.00 :   2d6f:       push   rbp
    0.00 :   2d70:       push   rbx
    0.00 :   2d71:       sub    rsp,0x18
    0.00 :   2d75:       mov    QWORD PTR [rsp+0x8],rdx
         :          {
         :          assert (hash_table);
    0.00 :   2d7a:       test   rdi,rdi
    0.00 :   2d7d:       je     2e88 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x125>
    0.00 :   2d83:       mov    rbx,rdi
    0.00 :   2d86:       mov    rbp,rsi
         :          _Z23__HashTableSearchForKeyIPcS0_EmP9HashTableIT_T0_ES2_():
         :          uint64_t position = __HashTableGetPosition (hash_table, key);
    4.17 :   2d89:       call   268b <unsigned long __HashTableGetPosition<char*, char*>(HashTable<char*, char*>*, char*)>
         :          if (hash_table->buckets[position].status == BUCKET_EMPTY)
    0.00 :   2d8e:       lea    rdx,[rax+rax*2]
    0.00 :   2d92:       mov    rax,QWORD PTR [rbx+0x10]
    2.08 :   2d96:       lea    rax,[rax+rdx*8]
    0.00 :   2d9a:       cmp    DWORD PTR [rax+0x10],0xbeef
   45.83 :   2da1:       je     2deb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x88>
         :          uint64_t val_pos =  hash_table->buckets[position].start_index;
    0.00 :   2da3:       mov    r13,QWORD PTR [rax]
         :          uint64_t bucket_size = hash_table->buckets[position].len;
    6.25 :   2da6:       mov    r15,QWORD PTR [rax+0x8]
         :          for (uint64_t i = 0; i < bucket_size; i++)
    0.00 :   2daa:       test   r15,r15
    0.00 :   2dad:       je     2deb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x88>
    0.00 :   2daf:       mov    r12d,0x0
         :          if (hash_table->key_equality_func (hash_table->values->list[val_pos].data.key, key))
    0.00 :   2db5:       mov    r14,r13
    0.00 :   2db8:       shl    r14,0x5
    0.00 :   2dbc:       mov    rax,QWORD PTR [rbx+0x18]
    0.00 :   2dc0:       mov    rax,QWORD PTR [rax]
    0.00 :   2dc3:       mov    rdi,QWORD PTR [rax+r14*1+0x10]
   29.17 :   2dc8:       mov    rsi,rbp
    0.00 :   2dcb:       call   QWORD PTR [rbx+0x8]
    0.00 :   2dce:       test   al,al
    0.00 :   2dd0:       jne    2ea7 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x144>
         :          val_pos = (uint64_t) hash_table->values->list[val_pos].next;
    0.00 :   2dd6:       mov    rax,QWORD PTR [rbx+0x18]
    0.00 :   2dda:       mov    rax,QWORD PTR [rax]
    0.00 :   2ddd:       movsxd r13,DWORD PTR [rax+r14*1+0x4]
         :          for (uint64_t i = 0; i < bucket_size; i++)
    2.08 :   2de2:       add    r12,0x1
    0.00 :   2de6:       cmp    r15,r12
    0.00 :   2de9:       jne    2db5 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x52>
         :          _Z15HashTableInsertIPcS0_EbP9HashTableIT_T0_ES2_S3_():
         :          // check if key is already in the table
         :          if (__HashTableSearchForKey(hash_table, key) != (uint64_t) MAX_LIST_ELEMENT)
         :          ASS (false && "KEY IS ALREADY IN THE TABLE", false);
         :
         :          // check capacity and increase if needed
         :          if (((double) hash_table->buckets_capacity *  HT_INCREASE_DECISION_COEF >= (double) hash_table->size) \
    0.00 :   2deb:       mov    rax,QWORD PTR [rbx+0x28]
    0.00 :   2def:       test   rax,rax
    0.00 :   2df2:       js     2efa <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x197>
    0.00 :   2df8:       pxor   xmm0,xmm0
    0.00 :   2dfc:       cvtsi2sd xmm0,rax
    4.17 :   2e01:       mulsd  xmm0,QWORD PTR [rip+0x1e27]        # 4c30 <_IO_stdin_used+0xc30>
    0.00 :   2e09:       mov    rax,QWORD PTR [rbx+0x20]
    0.00 :   2e0d:       test   rax,rax
    0.00 :   2e10:       js     2f18 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x1b5>
    0.00 :   2e16:       pxor   xmm1,xmm1
    0.00 :   2e1a:       cvtsi2sd xmm1,rax
    0.00 :   2e1f:       comisd xmm0,xmm1
    0.00 :   2e23:       jb     2e2f <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0xcc>
         :          && hash_table->resizable)
    0.00 :   2e25:       cmp    BYTE PTR [rbx+0x30],0x0
    0.00 :   2e29:       jne    2f36 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x1d3>
         :          HashTableRehash (hash_table, false);
         :
         :          HT_Pair<K, V> pair = HashTablePairCtor (key, value);
         :          uint64_t position = __HashTableGetPosition (hash_table, key);
    0.00 :   2e2f:       mov    rsi,rbp
    0.00 :   2e32:       mov    rdi,rbx
    0.00 :   2e35:       call   268b <unsigned long __HashTableGetPosition<char*, char*>(HashTable<char*, char*>*, char*)>
         :
         :          if (hash_table->buckets[position].status == BUCKET_EMPTY)
    0.00 :   2e3a:       lea    r12,[rax+rax*2]
    0.00 :   2e3e:       shl    r12,0x3
    0.00 :   2e42:       mov    rax,r12
    0.00 :   2e45:       add    rax,QWORD PTR [rbx+0x10]
    0.00 :   2e49:       cmp    DWORD PTR [rax+0x10],0xbeef
    0.00 :   2e50:       je     2f48 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x1e5>
         :          else
         :          {
         :          // check size and go through list
         :          uint64_t index_to_insert_after = hash_table->buckets[position].start_index;
         :
         :          int list_position = LLInsertAfter (hash_table->values, (int) index_to_insert_after, pair);
    0.00 :   2e56:       mov    rsi,QWORD PTR [rax]
    0.00 :   2e59:       mov    rdi,QWORD PTR [rbx+0x18]
    0.00 :   2e5d:       mov    rdx,rbp
    0.00 :   2e60:       mov    rcx,QWORD PTR [rsp+0x8]
    0.00 :   2e65:       call   28a1 <int LLInsertAfter<HT_Pair<char*, char*> >(LinkedList<HT_Pair<char*, char*> >*, int, HT_Pair<char*, char*>)>
         :          ASS (list_position > 0 && "Incorrect list position", false);
    0.00 :   2e6a:       test   eax,eax
    0.00 :   2e6c:       jle    2fc1 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x25e>
         :          hash_table->buckets[position].len += 1;
    0.00 :   2e72:       add    r12,QWORD PTR [rbx+0x10]
    0.00 :   2e76:       add    QWORD PTR [r12+0x8],0x1
         :          hash_table->buckets_capacity += 1;
    0.00 :   2e7c:       add    QWORD PTR [rbx+0x28],0x1
         :
         :          return true;
    0.00 :   2e81:       mov    eax,0x1
    0.00 :   2e86:       jmp    2eeb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x188>
         :          assert (hash_table);
    0.00 :   2e88:       lea    rcx,[rip+0x1c51]        # 4ae0 <_IO_stdin_used+0xae0>
    0.00 :   2e8f:       mov    edx,0xdf
    0.00 :   2e94:       lea    rsi,[rip+0x1458]        # 42f3 <_IO_stdin_used+0x2f3>
    0.00 :   2e9b:       lea    rdi,[rip+0x146f]        # 4311 <_IO_stdin_used+0x311>
    0.00 :   2ea2:       call   1240 <__assert_fail@plt>
         :          if (__HashTableSearchForKey(hash_table, key) != (uint64_t) MAX_LIST_ELEMENT)
    0.00 :   2ea7:       mov    rax,QWORD PTR [rbx+0x18]
    0.00 :   2eab:       mov    eax,DWORD PTR [rax+0x10]
    0.00 :   2eae:       add    eax,0x1
    0.00 :   2eb1:       cdqe
    0.00 :   2eb3:       cmp    rax,r13
    0.00 :   2eb6:       je     2deb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x88>
         :
         :          # ifdef __va_arg_pack
         :          __fortify_function int
         :          fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
         :          {
         :          return __fprintf_chk (__stream, __USE_FORTIFY_LEVEL - 1, __fmt,
    0.00 :   2ebc:       mov    r8d,0xe3
         :          fprintf():
    0.00 :   2ec2:       lea    rcx,[rip+0x142a]        # 42f3 <_IO_stdin_used+0x2f3>
    0.00 :   2ec9:       lea    rdx,[rip+0x1c60]        # 4b30 <_IO_stdin_used+0xb30>
    0.00 :   2ed0:       mov    esi,0x1
    0.00 :   2ed5:       mov    rdi,QWORD PTR [rip+0x4144]        # 7020 <stderr@@GLIBC_2.2.5>
    0.00 :   2edc:       mov    eax,0x0
    0.00 :   2ee1:       call   1300 <__fprintf_chk@plt>
         :          _Z15HashTableInsertIPcS0_EbP9HashTableIT_T0_ES2_S3_():
         :          ASS (false && "KEY IS ALREADY IN THE TABLE", false);
    0.00 :   2ee6:       mov    eax,0x0
         :          }
         :          }
    2.08 :   2eeb:       add    rsp,0x18
    2.08 :   2eef:       pop    rbx
    2.08 :   2ef0:       pop    rbp
    0.00 :   2ef1:       pop    r12
    0.00 :   2ef3:       pop    r13
    0.00 :   2ef5:       pop    r14
    0.00 :   2ef7:       pop    r15
    0.00 :   2ef9:       ret
         :          if (((double) hash_table->buckets_capacity *  HT_INCREASE_DECISION_COEF >= (double) hash_table->size) \
    0.00 :   2efa:       mov    rdx,rax
    0.00 :   2efd:       shr    rdx,1
    0.00 :   2f00:       and    eax,0x1
    0.00 :   2f03:       or     rdx,rax
    0.00 :   2f06:       pxor   xmm0,xmm0
    0.00 :   2f0a:       cvtsi2sd xmm0,rdx
    0.00 :   2f0f:       addsd  xmm0,xmm0
    0.00 :   2f13:       jmp    2e01 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x9e>
    0.00 :   2f18:       mov    rdx,rax
    0.00 :   2f1b:       shr    rdx,1
    0.00 :   2f1e:       and    eax,0x1
    0.00 :   2f21:       or     rdx,rax
    0.00 :   2f24:       pxor   xmm1,xmm1
    0.00 :   2f28:       cvtsi2sd xmm1,rdx
    0.00 :   2f2d:       addsd  xmm1,xmm1
    0.00 :   2f31:       jmp    2e1f <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0xbc>
         :          HashTableRehash (hash_table, false);
    0.00 :   2f36:       mov    esi,0x0
    0.00 :   2f3b:       mov    rdi,rbx
    0.00 :   2f3e:       call   29dd <bool HashTableRehash<char*, char*>(HashTable<char*, char*>*, bool)>
    0.00 :   2f43:       jmp    2e2f <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0xcc>
         :          int list_position = LLInsertAfter (hash_table->values, hash_table->values->list[0].prev, pair);
    0.00 :   2f48:       mov    rdi,QWORD PTR [rbx+0x18]
    0.00 :   2f4c:       mov    rax,QWORD PTR [rdi]
    0.00 :   2f4f:       mov    rdx,rbp
    0.00 :   2f52:       mov    rcx,QWORD PTR [rsp+0x8]
    0.00 :   2f57:       mov    esi,DWORD PTR [rax]
    0.00 :   2f59:       call   28a1 <int LLInsertAfter<HT_Pair<char*, char*> >(LinkedList<HT_Pair<char*, char*> >*, int, HT_Pair<char*, char*>)>
         :          ASS (list_position > 0, false);
    0.00 :   2f5e:       test   eax,eax
    0.00 :   2f60:       jle    2f8d <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x22a>
         :          hash_table->buckets[position] = { .start_index = (uint64_t) list_position,
    0.00 :   2f62:       add    r12,QWORD PTR [rbx+0x10]
    0.00 :   2f66:       cdqe
    0.00 :   2f68:       mov    QWORD PTR [r12],rax
    0.00 :   2f6c:       mov    QWORD PTR [r12+0x8],0x1
    0.00 :   2f75:       mov    DWORD PTR [r12+0x10],0xbaca
         :          hash_table->buckets_capacity += 1;
    0.00 :   2f7e:       add    QWORD PTR [rbx+0x28],0x1
         :          return true;
    0.00 :   2f83:       mov    eax,0x1
    0.00 :   2f88:       jmp    2eeb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x188>
    0.00 :   2f8d:       mov    r8d,0xf1
         :          fprintf():
    0.00 :   2f93:       lea    rcx,[rip+0x1359]        # 42f3 <_IO_stdin_used+0x2f3>
    0.00 :   2f9a:       lea    rdx,[rip+0x1be7]        # 4b88 <_IO_stdin_used+0xb88>
    0.00 :   2fa1:       mov    esi,0x1
    0.00 :   2fa6:       mov    rdi,QWORD PTR [rip+0x4073]        # 7020 <stderr@@GLIBC_2.2.5>
    0.00 :   2fad:       mov    eax,0x0
    0.00 :   2fb2:       call   1300 <__fprintf_chk@plt>
         :          _Z15HashTableInsertIPcS0_EbP9HashTableIT_T0_ES2_S3_():
         :          ASS (list_position > 0, false);
    0.00 :   2fb7:       mov    eax,0x0
    0.00 :   2fbc:       jmp    2eeb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x188>
    0.00 :   2fc1:       mov    r8d,0x100
         :          fprintf():
    0.00 :   2fc7:       lea    rcx,[rip+0x1325]        # 42f3 <_IO_stdin_used+0x2f3>
    0.00 :   2fce:       lea    rdx,[rip+0x1bfb]        # 4bd0 <_IO_stdin_used+0xbd0>
    0.00 :   2fd5:       mov    esi,0x1
    0.00 :   2fda:       mov    rdi,QWORD PTR [rip+0x403f]        # 7020 <stderr@@GLIBC_2.2.5>
    0.00 :   2fe1:       mov    eax,0x0
    0.00 :   2fe6:       call   1300 <__fprintf_chk@plt>
         :          _Z15HashTableInsertIPcS0_EbP9HashTableIT_T0_ES2_S3_():
         :          ASS (list_position > 0 && "Incorrect list position", false);
    0.00 :   2feb:       mov    eax,0x0
    0.00 :   2ff0:       jmp    2eeb <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x188>
#+END_SRC

#+BEGIN_HTML
  </details>
#+END_HTML

В ходе анализа дизассемблированного кода было выявлено, что самая медленная часть находится не в самой функции =HashTableInsert=, а в =HashTableSearchForKey=, которую вызывает первая для проверки коллизий. Самая медленная строка, на удивление -- возвращение обратно в вызывающую функцию в случае, когда у нас есть бакет с таким же хэшем, но данного элемента в этом бакете нет, а именно: =58,64 │     → je       402e53 <bool HashTableInsert<char*, char*>(HashTable<char*, char*>*, char*, char*)+0x103>=.

После длительного анализа кода, было сделано предположение, что инструкция занимает так много времени не из-за какого-то бранч-миса или плохо оптимизированной функции, а просто потому, что в таком случае происходит линейный поиск, как это видно из кода функции:
#+BEGIN_HTML
  <details>
  <summary>Код функции <code>__HashTableSearchForKey</code></summary>
#+END_HTML
#+BEGIN_SRC
template <typename K, typename V>
uint64_t __HashTableSearchForKey (HashTable<K, V>* hash_table, K key)
{
    uint64_t position = __HashTableGetPosition (hash_table, key);

    if (hash_table->buckets[position].status == BUCKET_NOT_EMPTY)
    {   
        uint64_t val_pos =  hash_table->buckets[position].start_index;
        uint64_t bucket_size = hash_table->buckets[position].len;

        for (uint64_t i = 0; i < bucket_size; i++)
        {   
            if (hash_table->key_equality_func (hash_table->values->list[val_pos].data.key, key))
                return val_pos;

            val_pos = (uint64_t) hash_table->values->list[val_pos].next;
        }
    }


    return (uint64_t) MAX_LIST_ELEMENT;
}
#+END_SRC

#+BEGIN_HTML
  </details>
#+END_HTML

То есть при возникновении коллизии, программа просматривает весь бакет на наличие совпадаюшего элемента. Из-за этого линейного поиска возврат из функции занимает долго времени. К сожалению или счастью, оптимизировать здесь нечего.

